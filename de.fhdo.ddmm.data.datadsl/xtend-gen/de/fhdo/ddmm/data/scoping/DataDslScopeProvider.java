/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.data.scoping;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import de.fhdo.ddmm.data.ComplexType;
import de.fhdo.ddmm.data.ComplexTypeImport;
import de.fhdo.ddmm.data.Context;
import de.fhdo.ddmm.data.DataModel;
import de.fhdo.ddmm.data.DataPackage;
import de.fhdo.ddmm.data.DataStructure;
import de.fhdo.ddmm.data.PossiblyImportedComplexType;
import de.fhdo.ddmm.data.Version;
import de.fhdo.ddmm.data.scoping.AbstractDataDslScopeProvider;
import de.fhdo.ddmm.utils.DdmmUtils;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * Scope provider for data models.
 */
@SuppressWarnings("all")
public class DataDslScopeProvider extends AbstractDataDslScopeProvider {
  /**
   * Build scope for a given context and reference
   */
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (context instanceof PossiblyImportedComplexType) {
      _matched=true;
      _switchResult = this.getScopeForPossiblyImportedComplexTypes(((PossiblyImportedComplexType)context), reference);
    }
    if (!_matched) {
      if (context instanceof DataStructure) {
        _matched=true;
        _switchResult = this.getScopeForDataStructures(((DataStructure)context), reference);
      }
    }
    final IScope scope = _switchResult;
    if ((scope != null)) {
      return scope;
    } else {
      if ((scope == null)) {
        return super.getScope(context, reference);
      }
    }
    return null;
  }
  
  /**
   * Build scope for possibly imported complex types
   */
  private IScope getScopeForPossiblyImportedComplexTypes(final PossiblyImportedComplexType type, final EReference reference) {
    if ((reference != DataPackage.Literals.POSSIBLY_IMPORTED_COMPLEX_TYPE__COMPLEX_TYPE)) {
      return null;
    }
    EObject container = null;
    List<String> qualifiedNameParts = null;
    final Version containingVersion = EcoreUtil2.<Version>getContainerOfType(type, Version.class);
    final Context containingContext = EcoreUtil2.<Context>getContainerOfType(type, Context.class);
    final DataModel containingDataModel = EcoreUtil2.<DataModel>getContainerOfType(type, DataModel.class);
    if ((containingVersion != null)) {
      container = containingVersion;
      qualifiedNameParts = containingVersion.getQualifiedNameParts();
    } else {
      if ((containingContext != null)) {
        container = containingContext;
        qualifiedNameParts = containingContext.getQualifiedNameParts();
      } else {
        if ((containingDataModel != null)) {
          container = containingDataModel;
          qualifiedNameParts = null;
        }
      }
    }
    String _xifexpression = null;
    ComplexTypeImport _import = type.getImport();
    boolean _tripleNotEquals = (_import != null);
    if (_tripleNotEquals) {
      _xifexpression = type.getImport().getImportURI();
    }
    final String importUri = _xifexpression;
    final Function<DataModel, List<ComplexType>> _function = (DataModel it) -> {
      return IterableExtensions.<ComplexType>toList(it.getContainedComplexTypes());
    };
    final Function<ComplexType, List<String>> _function_1 = (ComplexType it) -> {
      return it.getQualifiedNameParts();
    };
    return DdmmUtils.<EObject, DataModel, ComplexType>getScopeForPossiblyImportedConcept(container, qualifiedNameParts, 
      DataModel.class, importUri, _function, _function_1);
  }
  
  /**
   * Build scope for possibly imported complex types
   */
  private IScope getScopeForDataStructures(final DataStructure structure, final EReference reference) {
    if ((reference != DataPackage.Literals.DATA_STRUCTURE__SUPER)) {
      return null;
    }
    final DataModel modelRoot = EcoreUtil2.<DataModel>getContainerOfType(structure, DataModel.class);
    final Function1<ComplexType, Boolean> _function = (ComplexType it) -> {
      return Boolean.valueOf(((it instanceof DataStructure) && (!Objects.equal(it, structure))));
    };
    final Iterable<ComplexType> localStructures = IterableExtensions.<ComplexType>filter(modelRoot.getContainedComplexTypes(), _function);
    final Function<ComplexType, List<String>> _function_1 = (ComplexType it) -> {
      return it.getQualifiedNameParts();
    };
    return DdmmUtils.<ComplexType, DataStructure, DataModel>getScopeWithRelativeQualifiedNames(
      IterableExtensions.<ComplexType>toList(localStructures), _function_1, structure, 
      structure.getQualifiedNameParts(), 
      DataModel.class);
  }
}
