/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.technology.mappingdsl.scoping;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import de.fhdo.ddmm.data.ComplexType;
import de.fhdo.ddmm.data.DataField;
import de.fhdo.ddmm.data.DataStructure;
import de.fhdo.ddmm.data.ListType;
import de.fhdo.ddmm.data.PossiblyImportedComplexType;
import de.fhdo.ddmm.data.PrimitiveType;
import de.fhdo.ddmm.data.Type;
import de.fhdo.ddmm.service.Import;
import de.fhdo.ddmm.service.ImportedType;
import de.fhdo.ddmm.service.Interface;
import de.fhdo.ddmm.service.Microservice;
import de.fhdo.ddmm.service.Operation;
import de.fhdo.ddmm.service.Parameter;
import de.fhdo.ddmm.service.ReferredOperation;
import de.fhdo.ddmm.service.ServiceModel;
import de.fhdo.ddmm.technology.CommunicationType;
import de.fhdo.ddmm.technology.DataFormat;
import de.fhdo.ddmm.technology.ExchangePattern;
import de.fhdo.ddmm.technology.JoinPointType;
import de.fhdo.ddmm.technology.Protocol;
import de.fhdo.ddmm.technology.ServiceAspect;
import de.fhdo.ddmm.technology.Technology;
import de.fhdo.ddmm.technology.TechnologyPackage;
import de.fhdo.ddmm.technology.TechnologySpecificDataStructure;
import de.fhdo.ddmm.technology.TechnologySpecificListType;
import de.fhdo.ddmm.technology.TechnologySpecificPrimitiveType;
import de.fhdo.ddmm.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.ddmm.technology.mapping.ComplexParameterMapping;
import de.fhdo.ddmm.technology.mapping.DataFieldHierarchy;
import de.fhdo.ddmm.technology.mapping.ImportedMicroservice;
import de.fhdo.ddmm.technology.mapping.InterfaceMapping;
import de.fhdo.ddmm.technology.mapping.MappingPackage;
import de.fhdo.ddmm.technology.mapping.MicroserviceMapping;
import de.fhdo.ddmm.technology.mapping.OperationMapping;
import de.fhdo.ddmm.technology.mapping.ParameterMapping;
import de.fhdo.ddmm.technology.mapping.PrimitiveParameterMapping;
import de.fhdo.ddmm.technology.mapping.ReferredOperationMapping;
import de.fhdo.ddmm.technology.mapping.TechnologyMapping;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificDataFieldTypeMapping;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificEndpoint;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificImportedServiceAspect;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificProtocol;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificProtocolSpecification;
import de.fhdo.ddmm.technology.mappingdsl.scoping.AbstractMappingDslScopeProvider;
import de.fhdo.ddmm.utils.DdmmUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;

/**
 * This class implements a custom scope provider for the Mapping DSL.
 */
@SuppressWarnings("all")
public class MappingDslScopeProvider extends AbstractMappingDslScopeProvider {
  /**
   * Build scope for a given context and a given reference
   */
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (context instanceof MicroserviceMapping) {
      _matched=true;
      _switchResult = this.getScope(((MicroserviceMapping)context), reference);
    }
    if (!_matched) {
      if (context instanceof ImportedMicroservice) {
        _matched=true;
        _switchResult = this.getScope(((ImportedMicroservice)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificProtocolSpecification) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificProtocolSpecification)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificProtocol) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificProtocol)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificEndpoint) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificEndpoint)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof InterfaceMapping) {
        _matched=true;
        _switchResult = this.getScope(((InterfaceMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof OperationMapping) {
        _matched=true;
        _switchResult = this.getScope(((OperationMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ReferredOperationMapping) {
        _matched=true;
        _switchResult = this.getScope(((ReferredOperationMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof PrimitiveParameterMapping) {
        _matched=true;
        _switchResult = this.getScope(((PrimitiveParameterMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ComplexParameterMapping) {
        _matched=true;
        _switchResult = this.getScope(((ComplexParameterMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificDataFieldTypeMapping) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificDataFieldTypeMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof DataFieldHierarchy) {
        _matched=true;
        _switchResult = this.getScope(((DataFieldHierarchy)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificImportedServiceAspect) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificImportedServiceAspect)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificPropertyValueAssignment) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificPropertyValueAssignment)context), reference);
      }
    }
    final IScope scope = _switchResult;
    if ((scope != null)) {
      return scope;
    } else {
      if ((scope == null)) {
        return super.getScope(context, reference);
      }
    }
    return null;
  }
  
  /**
   * Build scope for microservice mappings and the given reference
   */
  private IScope getScope(final MicroserviceMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_MICROSERVICE__IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(mapping, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for interface mappings and the given reference
   */
  private IScope getScope(final InterfaceMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.INTERFACE_MAPPING__INTERFACE)) {
      _matched=true;
      return this.getScopeForInterfaces(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    return null;
  }
  
  /**
   * Build scope for operation mappings and the given reference
   */
  private IScope getScope(final OperationMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.OPERATION_MAPPING__OPERATION)) {
      _matched=true;
      return this.getScopeForOperations(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    return null;
  }
  
  /**
   * Build scope for referred operation mappings and the given reference
   */
  private IScope getScope(final ReferredOperationMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.REFERRED_OPERATION_MAPPING__OPERATION)) {
      _matched=true;
      return this.getScopeForReferredOperations(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    return null;
  }
  
  /**
   * Build scope for imported microservices
   */
  private IScope getScope(final ImportedMicroservice microservice, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_MICROSERVICE__IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(microservice, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_MICROSERVICE__MICROSERVICE)) {
        _matched=true;
        return this.getScopeForImportedMicroservices(microservice.getImport());
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific protocols and the given reference
   */
  private IScope getScope(final TechnologySpecificProtocolSpecification protocolSpecification, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(protocolSpecification, MicroserviceMapping.class));
    }
    return null;
  }
  
  /**
   * Build scope that comprises annotated technologies of an annotatable concept instance
   */
  private IScope getScopeForAnnotatedTechnologies(final MicroserviceMapping mapping) {
    return Scopes.scopeFor(mapping.getTechnologies());
  }
  
  /**
   * Build scope for technology protocols and the given reference
   */
  private IScope getScope(final TechnologySpecificProtocol protocol, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__PROTOCOL)) {
      _matched=true;
      return this.getScopeForTechnologySpecificProtocols(protocol);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__DATA_FORMAT)) {
        _matched=true;
        return this.getScopeForDataFormats(protocol);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific endpoints and the given reference
   */
  private IScope getScope(final TechnologySpecificEndpoint endpoint, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(endpoint, MicroserviceMapping.class));
    }
    return null;
  }
  
  /**
   * Build scope for primitive parameter mappings and the given reference
   */
  private IScope getScope(final PrimitiveParameterMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER)) {
      _matched=true;
      return this.getScopeForPrimitiveParameters(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.PRIMITIVE_PARAMETER_MAPPING__PRIMITIVE_TYPE)) {
        _matched=true;
        return this.getScopeForParameterTypes(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(mapping, MicroserviceMapping.class));
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.PRIMITIVE_PARAMETER_MAPPING__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForTypeDefinitionTechnology(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for complex parameter mappings and the given reference
   */
  private IScope getScope(final ComplexParameterMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER)) {
      _matched=true;
      return this.getScopeForComplexParameters(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(mapping, MicroserviceMapping.class));
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.COMPLEX_PARAMETER_MAPPING__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForTypeDefinitionTechnology(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.COMPLEX_PARAMETER_MAPPING__TECHNOLOGY_SPECIFIC_COMPLEX_TYPE)) {
        _matched=true;
        return this.getScopeForParameterTypes(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.DATA_FIELD_HIERARCHY__DATA_FIELDS)) {
        _matched=true;
        return this.getScopeForComplexDataFields(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific data field mappings and the given reference
   */
  private IScope getScope(final TechnologySpecificDataFieldTypeMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_DATA_FIELD_TYPE_MAPPING__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForTypeDefinitionTechnology(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_DATA_FIELD_TYPE_MAPPING__TYPE)) {
        _matched=true;
        return this.getScopeForParameterTypes(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for data field hierarchies and the given reference
   */
  private IScope getScope(final DataFieldHierarchy hierarchy, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.DATA_FIELD_HIERARCHY__DATA_FIELDS)) {
      _matched=true;
      return this.getScopeForComplexDataFields(hierarchy);
    }
    return null;
  }
  
  /**
   * Build scope for interfaces
   */
  private IScope getScopeForInterfaces(final InterfaceMapping mapping) {
    final MicroserviceMapping microserviceMapping = mapping.getMicroserviceMapping();
    final Microservice microservice = microserviceMapping.getMicroservice().getMicroservice();
    return Scopes.scopeFor(microservice.getInterfaces());
  }
  
  /**
   * Build scope for operations
   */
  private IScope getScopeForOperations(final OperationMapping mapping) {
    final MicroserviceMapping microserviceMapping = mapping.getMicroserviceMapping();
    final Microservice microservice = microserviceMapping.getMicroservice().getMicroservice();
    if ((microservice == null)) {
      return IScope.NULLSCOPE;
    }
    final Function1<Interface, EList<Operation>> _function = (Interface it) -> {
      return it.getOperations();
    };
    final Iterable<Operation> operations = Iterables.<Operation>concat(ListExtensions.<Interface, EList<Operation>>map(microservice.getInterfaces(), _function));
    final Function<Operation, QualifiedName> _function_1 = (Operation it) -> {
      return QualifiedName.create(it.getInterface().getName(), it.getName());
    };
    return Scopes.<Operation>scopeFor(operations, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for primitive parameters of operations
   */
  private IScope getScopeForPrimitiveParameters(final PrimitiveParameterMapping mapping) {
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      PrimitiveType _primitiveType = it.getPrimitiveType();
      return Boolean.valueOf((_primitiveType != null));
    };
    final List<Parameter> primitiveParameters = IterableExtensions.<Parameter>toList(IterableExtensions.<Parameter>filter(mapping.getOperationMapping().getOperation().getParameters(), _function));
    final Function1<Parameter, Boolean> _function_1 = (Parameter it) -> {
      return Boolean.valueOf(((it.getImportedType() != null) && (it.getImportedType().getType() instanceof TechnologySpecificPrimitiveType)));
    };
    Iterables.<Parameter>addAll(primitiveParameters, 
      IterableExtensions.<Parameter>filter(mapping.getOperationMapping().getOperation().getParameters(), _function_1));
    return Scopes.scopeFor(primitiveParameters);
  }
  
  /**
   * Build scope for complex parameters of operations
   */
  private IScope getScopeForComplexParameters(final ComplexParameterMapping mapping) {
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      return Boolean.valueOf(((it.getImportedType() != null) && (it.getImportedType().getType() instanceof ComplexType)));
    };
    final Iterable<Parameter> complexParameters = IterableExtensions.<Parameter>filter(mapping.getOperationMapping().getOperation().getParameters(), _function);
    return Scopes.scopeFor(complexParameters);
  }
  
  /**
   * Build scope for technology-specific types for complex parameters
   */
  private IScope getScopeForParameterTypes(final EObject mapping) {
    Type parameterType = null;
    Import technology = null;
    boolean _matched = false;
    if (mapping instanceof PrimitiveParameterMapping) {
      _matched=true;
      parameterType = ((PrimitiveParameterMapping)mapping).getParameter().getEffectiveType();
      technology = ((PrimitiveParameterMapping)mapping).getTechnology();
    }
    if (!_matched) {
      if (mapping instanceof ComplexParameterMapping) {
        _matched=true;
        parameterType = ((ComplexParameterMapping)mapping).getParameter().getImportedType().getType();
        technology = ((ComplexParameterMapping)mapping).getTechnology();
      }
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificDataFieldTypeMapping) {
        _matched=true;
        parameterType = IterableExtensions.<DataField>last(((TechnologySpecificDataFieldTypeMapping)mapping).getDataFieldHierarchy().getDataFields()).getEffectiveType();
        technology = ((TechnologySpecificDataFieldTypeMapping)mapping).getTechnology();
      }
    }
    if (!_matched) {
      return IScope.NULLSCOPE;
    }
    if ((parameterType == null)) {
      return IScope.NULLSCOPE;
    }
    Function<Technology, List<Type>> getImportedConcepts = null;
    Function<Type, List<String>> getConceptNameParts = null;
    if ((parameterType instanceof PrimitiveType)) {
      final Function<Technology, List<Type>> _function = (Technology it) -> {
        final Function1<TechnologySpecificPrimitiveType, Type> _function_1 = (TechnologySpecificPrimitiveType it_1) -> {
          return ((Type) it_1);
        };
        return ListExtensions.<TechnologySpecificPrimitiveType, Type>map(it.getPrimitiveTypes(), _function_1);
      };
      getImportedConcepts = _function;
      final Function<Type, List<String>> _function_1 = (Type it) -> {
        return ((TechnologySpecificPrimitiveType) it).getQualifiedNameParts();
      };
      getConceptNameParts = _function_1;
    } else {
      if ((parameterType instanceof ComplexType)) {
        boolean _isIsStructure = ((ComplexType)parameterType).isIsStructure();
        if (_isIsStructure) {
          final Function<Technology, List<Type>> _function_2 = (Technology it) -> {
            final Function1<TechnologySpecificDataStructure, Type> _function_3 = (TechnologySpecificDataStructure it_1) -> {
              return ((Type) it_1);
            };
            return ListExtensions.<TechnologySpecificDataStructure, Type>map(it.getDataStructures(), _function_3);
          };
          getImportedConcepts = _function_2;
          final Function<Type, List<String>> _function_3 = (Type it) -> {
            return ((TechnologySpecificDataStructure) it).getQualifiedNameParts();
          };
          getConceptNameParts = _function_3;
        } else {
          if ((((ComplexType)parameterType).isIsStructuredList() || ((ComplexType)parameterType).isIsPrimitiveList())) {
            final Function<Technology, List<Type>> _function_4 = (Technology it) -> {
              final Function1<TechnologySpecificListType, Type> _function_5 = (TechnologySpecificListType it_1) -> {
                return ((Type) it_1);
              };
              return ListExtensions.<TechnologySpecificListType, Type>map(it.getListTypes(), _function_5);
            };
            getImportedConcepts = _function_4;
            final Function<Type, List<String>> _function_5 = (Type it) -> {
              return ((TechnologySpecificListType) it).getQualifiedNameParts();
            };
            getConceptNameParts = _function_5;
          }
        }
      }
    }
    return DdmmUtils.<Import, Technology, Type>getScopeForPossiblyImportedConcept(technology, 
      null, 
      Technology.class, 
      technology.getImportURI(), getImportedConcepts, getConceptNameParts);
  }
  
  /**
   * Build scope for microservice mapping technology that defines types
   */
  private IScope getScopeForTypeDefinitionTechnology(final EObject context) {
    MicroserviceMapping _xifexpression = null;
    if ((context instanceof MicroserviceMapping)) {
      _xifexpression = ((MicroserviceMapping)context);
    } else {
      _xifexpression = EcoreUtil2.<MicroserviceMapping>getContainerOfType(context, MicroserviceMapping.class);
    }
    final MicroserviceMapping mapping = _xifexpression;
    if ((mapping == null)) {
      return IScope.NULLSCOPE;
    }
    final Function1<Import, Boolean> _function = (Import it) -> {
      boolean _xblockexpression = false;
      {
        final Technology modelRoot = DdmmUtils.<Technology>getImportedModelRoot(it.eResource(), it.getImportURI(), Technology.class);
        _xblockexpression = ((modelRoot != null) && (!modelRoot.getPrimitiveTypes().isEmpty()));
      }
      return Boolean.valueOf(_xblockexpression);
    };
    final Import typeDefinitionTechnology = IterableExtensions.<Import>findFirst(mapping.getTechnologies(), _function);
    if ((typeDefinitionTechnology == null)) {
      return IScope.NULLSCOPE;
    }
    return Scopes.scopeFor(Collections.<EObject>unmodifiableList(CollectionLiterals.<EObject>newArrayList(typeDefinitionTechnology)));
  }
  
  /**
   * Build scope for data fields of complex parameters' types on the first data field hierarchy
   * level. It contains all direct children of the complex parameter being mapped.
   */
  private IScope getScopeForComplexDataFields(final ComplexParameterMapping mapping) {
    ImportedType _importedType = mapping.getParameter().getImportedType();
    boolean _tripleEquals = (_importedType == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    Type _type = mapping.getParameter().getImportedType().getType();
    final ComplexType previousType = ((ComplexType) _type);
    final EList<DataField> nextLeveldDataFields = this.nextDataFieldsInHierarchy(previousType);
    if ((nextLeveldDataFields != null)) {
      return Scopes.scopeFor(nextLeveldDataFields);
    } else {
      return IScope.NULLSCOPE;
    }
  }
  
  /**
   * Build scope for data fields of complex parameters' types on hierarchy levels, i.e., the
   * context is a data field hierarchy
   */
  private IScope getScopeForComplexDataFields(final DataFieldHierarchy hierarchy) {
    DataField previousDataField = null;
    if (((hierarchy.getPrevious() == null) || hierarchy.getPrevious().getDataFields().isEmpty())) {
      previousDataField = null;
    } else {
      previousDataField = IterableExtensions.<DataField>last(hierarchy.getPrevious().getDataFields());
    }
    if ((previousDataField == null)) {
      final ComplexParameterMapping complexMapping = EcoreUtil2.<ComplexParameterMapping>getContainerOfType(hierarchy, ComplexParameterMapping.class);
      return this.getScopeForComplexDataFields(complexMapping);
    }
    PossiblyImportedComplexType _complexType = previousDataField.getComplexType();
    boolean _tripleEquals = (_complexType == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    final ComplexType previousType = previousDataField.getComplexType().getComplexType();
    final EList<DataField> nextLeveldDataFields = this.nextDataFieldsInHierarchy(previousType);
    if ((nextLeveldDataFields != null)) {
      return Scopes.scopeFor(nextLeveldDataFields);
    } else {
      return IScope.NULLSCOPE;
    }
  }
  
  /**
   * Convenience method to retrieve the data fields of the next level of a data field hierarchy
   */
  private EList<DataField> nextDataFieldsInHierarchy(final ComplexType previousType) {
    boolean _isIsPrimitiveList = previousType.isIsPrimitiveList();
    if (_isIsPrimitiveList) {
      return null;
    }
    EList<DataField> _xifexpression = null;
    boolean _isIsStructure = previousType.isIsStructure();
    if (_isIsStructure) {
      _xifexpression = ((DataStructure) previousType).getEffectiveFields();
    } else {
      EList<DataField> _xifexpression_1 = null;
      boolean _isIsStructuredList = previousType.isIsStructuredList();
      if (_isIsStructuredList) {
        _xifexpression_1 = ((ListType) previousType).getDataFields();
      }
      _xifexpression = _xifexpression_1;
    }
    final EList<DataField> nextDataFields = _xifexpression;
    EList<DataField> _xifexpression_2 = null;
    boolean _isEmpty = nextDataFields.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      _xifexpression_2 = nextDataFields;
    } else {
      _xifexpression_2 = null;
    }
    return _xifexpression_2;
  }
  
  /**
   * Build scope for referred operations
   */
  private IScope getScopeForReferredOperations(final ReferredOperationMapping mapping) {
    final MicroserviceMapping microserviceMapping = mapping.getMicroserviceMapping();
    final Microservice microservice = microserviceMapping.getMicroservice().getMicroservice();
    final Function1<Interface, EList<ReferredOperation>> _function = (Interface it) -> {
      return it.getReferredOperations();
    };
    final Iterable<ReferredOperation> operations = Iterables.<ReferredOperation>concat(ListExtensions.<Interface, EList<ReferredOperation>>map(microservice.getInterfaces(), _function));
    final Function<ReferredOperation, QualifiedName> _function_1 = (ReferredOperation it) -> {
      return QualifiedName.create(it.getInterface().getName(), it.getOperation().getName());
    };
    return Scopes.<ReferredOperation>scopeFor(operations, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for technology-specific protocols
   */
  private IScope getScopeForTechnologySpecificProtocols(final TechnologySpecificProtocol protocol) {
    Import _technology = protocol.getTechnology();
    boolean _tripleEquals = (_technology == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    final TechnologySpecificProtocolSpecification protocolSpecification = protocol.getProtocolSpecification();
    CommunicationType _xifexpression = null;
    if ((protocolSpecification != null)) {
      _xifexpression = protocolSpecification.getCommunicationType();
    }
    final CommunicationType forCommunicationType = _xifexpression;
    List<Predicate<Protocol>> _xifexpression_1 = null;
    if ((forCommunicationType != null)) {
      final Predicate<Protocol> _function = (Protocol it) -> {
        CommunicationType _communicationType = it.getCommunicationType();
        return Objects.equal(forCommunicationType, _communicationType);
      };
      _xifexpression_1 = Collections.<Predicate<Protocol>>unmodifiableList(CollectionLiterals.<Predicate<Protocol>>newArrayList(_function));
    }
    List<Predicate<Protocol>> communicationTypeFilter = _xifexpression_1;
    final Function<Technology, List<Protocol>> _function_1 = (Technology it) -> {
      return IterableExtensions.<Protocol>toList(it.getProtocols());
    };
    final Function<Protocol, List<String>> _function_2 = (Protocol it) -> {
      return it.getQualifiedNameParts();
    };
    final List<Predicate<Protocol>> _converted_communicationTypeFilter = (List<Predicate<Protocol>>)communicationTypeFilter;
    return DdmmUtils.<Import, Technology, Protocol>getScopeForPossiblyImportedConcept(
      protocol.getTechnology(), 
      null, 
      Technology.class, 
      protocol.getTechnology().getImportURI(), _function_1, _function_2, ((Predicate<Protocol>[])Conversions.unwrapArray(_converted_communicationTypeFilter, Predicate.class)));
  }
  
  /**
   * Build scope for protocol data formats
   */
  private IScope getScopeForDataFormats(final TechnologySpecificProtocol protocol) {
    Protocol _protocol = protocol.getProtocol();
    boolean _tripleEquals = (_protocol == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    final String protocolName = protocol.getProtocol().getName();
    if ((protocolName == null)) {
      return IScope.NULLSCOPE;
    }
    final Function1<Protocol, Boolean> _function = (Protocol it) -> {
      String _name = it.getName();
      return Boolean.valueOf(Objects.equal(_name, protocolName));
    };
    final EList<DataFormat> scopeElements = IterableExtensions.<Protocol>findFirst(protocol.getProtocol().getTechnology().getProtocols(), _function).getDataFormats();
    final Function<DataFormat, QualifiedName> _function_1 = (DataFormat it) -> {
      return QualifiedName.create(it.getFormatName());
    };
    return Scopes.<DataFormat>scopeFor(scopeElements, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for the actual microservices if the import was already specified
   */
  private IScope getScopeForImportedMicroservices(final Import import_) {
    if ((import_ == null)) {
      return IScope.NULLSCOPE;
    }
    final Function<ServiceModel, List<Microservice>> _function = (ServiceModel it) -> {
      return IterableExtensions.<Microservice>toList(it.getMicroservices());
    };
    final Function<Microservice, List<String>> _function_1 = (Microservice it) -> {
      return it.getQualifiedNameParts();
    };
    return DdmmUtils.<Import, ServiceModel, Microservice>getScopeForPossiblyImportedConcept(import_, 
      null, 
      ServiceModel.class, 
      import_.getImportURI(), _function, _function_1);
  }
  
  /**
   * Build scope for imported service aspects used to annotate microservices, interfaces,
   * operations, parameters, or data fields
   */
  private IScope getScope(final TechnologySpecificImportedServiceAspect importedAspect, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(importedAspect, MicroserviceMapping.class));
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT)) {
        _matched=true;
        return this.getScopeForImportedAspect(importedAspect);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY)) {
        _matched=true;
        return this.getScopeForAspectProperty(importedAspect);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific value assignment
   */
  private IScope getScope(final TechnologySpecificPropertyValueAssignment assignment, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY)) {
      _matched=true;
      return this.getScopeForAspectProperty(EcoreUtil2.<TechnologySpecificImportedServiceAspect>getContainerOfType(assignment, 
        TechnologySpecificImportedServiceAspect.class));
    }
    return null;
  }
  
  /**
   * Build scope for aspect properties
   */
  private IScope getScopeForAspectProperty(final TechnologySpecificImportedServiceAspect importedAspect) {
    return Scopes.scopeFor(importedAspect.getAspect().getProperties());
  }
  
  /**
   * Build scope for aspect of imported service aspect
   */
  private IScope getScopeForImportedAspect(final TechnologySpecificImportedServiceAspect aspect) {
    Import _technology = aspect.getTechnology();
    boolean _tripleEquals = (_technology == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    ExchangePattern forExchangePattern = null;
    CommunicationType forCommunicationType = null;
    List<Pair<Protocol, DataFormat>> forProtocolsAndDataFormats = null;
    final EObject mapping = aspect.eContainer();
    JoinPointType _switchResult = null;
    boolean _matched = false;
    if (mapping instanceof MicroserviceMapping) {
      _matched=true;
      JoinPointType _xblockexpression = null;
      {
        forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((MicroserviceMapping)mapping)).values());
        _xblockexpression = JoinPointType.MICROSERVICES;
      }
      _switchResult = _xblockexpression;
    }
    if (!_matched) {
      if (mapping instanceof InterfaceMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((InterfaceMapping)mapping)).values());
          _xblockexpression = JoinPointType.INTERFACES;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof OperationMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((OperationMapping)mapping)).values());
          _xblockexpression = JoinPointType.OPERATIONS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof ReferredOperationMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((ReferredOperationMapping)mapping)).values());
          _xblockexpression = JoinPointType.OPERATIONS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof ParameterMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          final Parameter parameter = ((ParameterMapping)mapping).getParameter();
          forCommunicationType = parameter.getCommunicationType();
          forExchangePattern = parameter.getExchangePattern();
          Pair<Protocol, DataFormat> _effectiveProtocolAndDataFormat = this.getEffectiveProtocolAndDataFormat(((ParameterMapping)mapping));
          forProtocolsAndDataFormats = Collections.<Pair<Protocol, DataFormat>>unmodifiableList(CollectionLiterals.<Pair<Protocol, DataFormat>>newArrayList(_effectiveProtocolAndDataFormat));
          _xblockexpression = JoinPointType.PARAMETERS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificDataFieldTypeMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          final ComplexParameterMapping parameterMapping = ((TechnologySpecificDataFieldTypeMapping)mapping).getParameterMapping();
          Pair<Protocol, DataFormat> _effectiveProtocolAndDataFormat = this.getEffectiveProtocolAndDataFormat(parameterMapping);
          forProtocolsAndDataFormats = Collections.<Pair<Protocol, DataFormat>>unmodifiableList(CollectionLiterals.<Pair<Protocol, DataFormat>>newArrayList(_effectiveProtocolAndDataFormat));
          final Parameter parameter = parameterMapping.getParameter();
          forCommunicationType = parameter.getCommunicationType();
          forExchangePattern = parameter.getExchangePattern();
          _xblockexpression = JoinPointType.DATA_FIELDS;
        }
        _switchResult = _xblockexpression;
      }
    }
    final JoinPointType joinPoint = _switchResult;
    final EList<EObject> resourceContents = DdmmUtils.getImportedModelContents(aspect.getTechnology().eResource(), 
      aspect.getTechnology().getImportURI());
    if (((resourceContents == null) || resourceContents.isEmpty())) {
      return IScope.NULLSCOPE;
    }
    EObject _get = resourceContents.get(0);
    final Function1<ServiceAspect, Boolean> _function = (ServiceAspect it) -> {
      return Boolean.valueOf(it.getJoinPoints().contains(joinPoint));
    };
    final List<ServiceAspect> declaredAspectsForJoinPoint = IterableExtensions.<ServiceAspect>toList(IterableExtensions.<ServiceAspect>filter(((Technology) _get).getServiceAspects(), _function));
    final ArrayList<ServiceAspect> scopeAspects = this.filterMatchingAspects(declaredAspectsForJoinPoint, forExchangePattern, forCommunicationType, forProtocolsAndDataFormats);
    final Function<ServiceAspect, QualifiedName> _function_1 = (ServiceAspect it) -> {
      return QualifiedName.create(it.getQualifiedNameParts());
    };
    return Scopes.<ServiceAspect>scopeFor(scopeAspects, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Convenience method to create a scope for imports of certain types
   */
  private IScope getScopeForImportsOfType(final EObject context, final Class<? extends EObject>... types) {
    final EList<Import> allImports = EcoreUtil2.<TechnologyMapping>getContainerOfType(context, TechnologyMapping.class).getImports();
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final Iterable<Import> validImports = DdmmUtils.<Import>getImportsOfModelTypes(allImports, _function, types);
    return Scopes.scopeFor(validImports);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of a microservice mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final MicroserviceMapping mapping) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> results = this.<EObject>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), null, null);
    final ArrayList<CommunicationType> missingCommunicationTypes = CollectionLiterals.<CommunicationType>newArrayList();
    boolean _containsKey = results.containsKey(CommunicationType.ASYNCHRONOUS);
    boolean _not = (!_containsKey);
    if (_not) {
      missingCommunicationTypes.add(CommunicationType.ASYNCHRONOUS);
    }
    boolean _containsKey_1 = results.containsKey(CommunicationType.SYNCHRONOUS);
    boolean _not_1 = (!_containsKey_1);
    if (_not_1) {
      missingCommunicationTypes.add(CommunicationType.SYNCHRONOUS);
    }
    boolean _isEmpty = missingCommunicationTypes.isEmpty();
    if (_isEmpty) {
      return results;
    }
    final Consumer<Import> _function = (Import it) -> {
      final Technology technologyModel = DdmmUtils.<Technology>getImportedModelRoot(it.eResource(), it.getImportURI(), Technology.class);
      final Consumer<CommunicationType> _function_1 = (CommunicationType communicationType) -> {
        Protocol defaultProtocol = null;
        DataFormat defaultDataFormat = null;
        final Function1<Protocol, Boolean> _function_2 = (Protocol it_1) -> {
          CommunicationType _communicationType = it_1.getCommunicationType();
          return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
        };
        final Function1<Protocol, Boolean> _function_3 = (Protocol it_1) -> {
          return Boolean.valueOf(it_1.isDefault());
        };
        defaultProtocol = IterableExtensions.<Protocol>findFirst(IterableExtensions.<Protocol>filter(technologyModel.getProtocols(), _function_2), _function_3);
        if ((defaultProtocol != null)) {
          defaultDataFormat = defaultProtocol.getDefaultFormat();
        }
        if ((defaultProtocol != null)) {
          results.put(communicationType, Pair.<Protocol, DataFormat>of(defaultProtocol, defaultDataFormat));
        }
      };
      missingCommunicationTypes.forEach(_function_1);
    };
    mapping.getTechnologies().forEach(_function);
    return results;
  }
  
  /**
   * Helper method to determine effective protocols and data formats of an interface mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final InterfaceMapping mapping) {
    final Function<MicroserviceMapping, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (MicroserviceMapping it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<MicroserviceMapping>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), mapping.getMicroserviceMapping(), _function);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of an operation mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final OperationMapping mapping) {
    final Function<MicroserviceMapping, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (MicroserviceMapping it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<MicroserviceMapping>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), mapping.getMicroserviceMapping(), _function);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of a referred operation
   * mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final ReferredOperationMapping mapping) {
    final Function<MicroserviceMapping, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (MicroserviceMapping it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<MicroserviceMapping>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), 
      mapping.getMicroserviceMapping(), _function);
  }
  
  /**
   * Helper method to determine effective protocol and data format for a parameter mapping with
   * consideration of its communication type
   */
  private Pair<Protocol, DataFormat> getEffectiveProtocolAndDataFormat(final ParameterMapping mapping) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> operationProtocolsAndDataFormats = this.getEffectiveProtocolsAndDataFormats(mapping.getOperationMapping());
    return operationProtocolsAndDataFormats.get(mapping.getParameter().getCommunicationType());
  }
  
  /**
   * Helper method to determine effective protocols and data formats from technology-specific
   * protocol specifications and possibly the containing concept, if protocol and data format
   * couldn't be determined for a communication type.
   * 
   * The method takes the following type arguments:
   *     - CONTAINER: The container of the technology-specific protocol specifications.
   * 
   * The function argument of the method returns for a given CONTAINER object the effective
   * protocols and data formats.
   */
  protected <CONTAINER extends EObject> Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final List<TechnologySpecificProtocolSpecification> protocolSpecifications, final CONTAINER container, final Function<CONTAINER, Map<CommunicationType, Pair<Protocol, DataFormat>>> getFromContainer) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> results = CollectionLiterals.<CommunicationType, Pair<Protocol, DataFormat>>newHashMap();
    final ArrayList<CommunicationType> missingCommunicationTypes = CollectionLiterals.<CommunicationType>newArrayList();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        CommunicationType _switchResult = null;
        if (i != null) {
          switch (i) {
            case 0:
              _switchResult = CommunicationType.ASYNCHRONOUS;
              break;
            case 1:
              _switchResult = CommunicationType.SYNCHRONOUS;
              break;
          }
        }
        final CommunicationType communicationType = _switchResult;
        Protocol protocol = null;
        DataFormat dataFormat = null;
        final Function1<TechnologySpecificProtocolSpecification, Boolean> _function = (TechnologySpecificProtocolSpecification it) -> {
          CommunicationType _communicationType = it.getCommunicationType();
          return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
        };
        TechnologySpecificProtocolSpecification protocolSpecification = IterableExtensions.<TechnologySpecificProtocolSpecification>findFirst(protocolSpecifications, _function);
        if ((((protocolSpecification != null) && 
          (protocolSpecification.getTechnologySpecificProtocol() != null)) && 
          (protocolSpecification.getTechnologySpecificProtocol().getProtocol() != null))) {
          protocol = protocolSpecification.getTechnologySpecificProtocol().getProtocol();
          DataFormat _elvis = null;
          DataFormat _dataFormat = protocolSpecification.getTechnologySpecificProtocol().getDataFormat();
          if (_dataFormat != null) {
            _elvis = _dataFormat;
          } else {
            DataFormat _defaultFormat = protocol.getDefaultFormat();
            _elvis = _defaultFormat;
          }
          dataFormat = _elvis;
        }
        if ((protocol != null)) {
          results.put(communicationType, Pair.<Protocol, DataFormat>of(protocol, dataFormat));
        } else {
          missingCommunicationTypes.add(communicationType);
        }
      }
    }
    if ((((container != null) && (getFromContainer != null)) && (!missingCommunicationTypes.isEmpty()))) {
      final Map<CommunicationType, Pair<Protocol, DataFormat>> containerResults = getFromContainer.apply(container);
      final Function1<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>, Boolean> _function = (Map.Entry<CommunicationType, Pair<Protocol, DataFormat>> it) -> {
        return Boolean.valueOf(missingCommunicationTypes.contains(it.getKey()));
      };
      final Consumer<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>> _function_1 = (Map.Entry<CommunicationType, Pair<Protocol, DataFormat>> it) -> {
        results.put(it.getKey(), it.getValue());
      };
      IterableExtensions.<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>>filter(containerResults.entrySet(), _function).forEach(_function_1);
    }
    return results;
  }
}
