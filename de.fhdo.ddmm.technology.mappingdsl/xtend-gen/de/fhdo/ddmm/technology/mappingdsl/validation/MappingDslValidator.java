/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.technology.mappingdsl.validation;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import de.fhdo.ddmm.data.ComplexType;
import de.fhdo.ddmm.data.DataField;
import de.fhdo.ddmm.data.PrimitiveType;
import de.fhdo.ddmm.data.PrimitiveValue;
import de.fhdo.ddmm.data.Type;
import de.fhdo.ddmm.service.Import;
import de.fhdo.ddmm.service.Parameter;
import de.fhdo.ddmm.service.ServicePackage;
import de.fhdo.ddmm.technology.CommunicationType;
import de.fhdo.ddmm.technology.DataFormat;
import de.fhdo.ddmm.technology.Protocol;
import de.fhdo.ddmm.technology.ServiceAspect;
import de.fhdo.ddmm.technology.Technology;
import de.fhdo.ddmm.technology.TechnologySpecificPrimitiveType;
import de.fhdo.ddmm.technology.TechnologySpecificProperty;
import de.fhdo.ddmm.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.ddmm.technology.mapping.ComplexParameterMapping;
import de.fhdo.ddmm.technology.mapping.ImportedMicroservice;
import de.fhdo.ddmm.technology.mapping.InterfaceMapping;
import de.fhdo.ddmm.technology.mapping.MappingPackage;
import de.fhdo.ddmm.technology.mapping.MicroserviceMapping;
import de.fhdo.ddmm.technology.mapping.OperationMapping;
import de.fhdo.ddmm.technology.mapping.ParameterMapping;
import de.fhdo.ddmm.technology.mapping.PrimitiveParameterMapping;
import de.fhdo.ddmm.technology.mapping.ReferredOperationMapping;
import de.fhdo.ddmm.technology.mapping.TechnologyMapping;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificDataFieldTypeMapping;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificEndpoint;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificImportedServiceAspect;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificProtocol;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificProtocolSpecification;
import de.fhdo.ddmm.technology.mappingdsl.validation.AbstractMappingDslValidator;
import de.fhdo.ddmm.typechecking.TypeChecker;
import de.fhdo.ddmm.typechecking.TypesNotCompatibleException;
import de.fhdo.ddmm.utils.DdmmUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains validation rules for the Mapping DSL.
 */
@SuppressWarnings("all")
public class MappingDslValidator extends AbstractMappingDslValidator {
  /**
   * Check that imported file is imported exactly once
   */
  @Check
  public void checkImportFileUniqueness(final TechnologyMapping model) {
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final Integer duplicateIndex = DdmmUtils.<Import, String>getDuplicateIndex(model.getImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final Import duplicate = model.getImports().get((duplicateIndex).intValue());
    this.error("File is already being imported", duplicate, 
      ServicePackage.Literals.IMPORT__IMPORT_URI);
  }
  
  /**
   * Check that technology is assigned only once to a microservice mapping
   */
  @Check
  public void checkTechnologyUniqueness(final MicroserviceMapping mapping) {
    final Function<Import, Import> _function = (Import it) -> {
      return it;
    };
    final Integer duplicateIndex = DdmmUtils.<Import, Import>getDuplicateIndex(mapping.getTechnologies(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate technology assignment");
      this.error(_builder.toString(), 
        MappingPackage.Literals.MICROSERVICE_MAPPING__TECHNOLOGIES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that only one annotated technology contains type definitions
   */
  @Check
  public void checkUniqueTypeDefinitionTechnology(final MicroserviceMapping mapping) {
    String typeDefinitionTechnologyName = null;
    int _size = mapping.getTechnologies().size();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        final Import technologyImport = mapping.getTechnologies().get((i).intValue());
        final Technology technologyModel = DdmmUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        if ((((!technologyModel.getPrimitiveTypes().isEmpty()) || 
          (!technologyModel.getListTypes().isEmpty())) || 
          (!technologyModel.getDataStructures().isEmpty()))) {
          if ((typeDefinitionTechnologyName == null)) {
            typeDefinitionTechnologyName = technologyModel.getName();
          } else {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Technology \"");
            _builder.append(typeDefinitionTechnologyName);
            _builder.append("\" already defines ");
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("technology-specific types. Only one technology per microservice may ");
            String _plus = (_builder.toString() + _builder_1);
            StringConcatenation _builder_2 = new StringConcatenation();
            _builder_2.append("define technology-specific types.");
            String _plus_1 = (_plus + _builder_2);
            this.error(_plus_1, 
              MappingPackage.Literals.MICROSERVICE_MAPPING__TECHNOLOGIES, (i).intValue());
          }
        }
      }
    }
  }
  
  /**
   * Check that annotated technologies define not only deployment-related concepts
   */
  @Check
  public void checkTechnologiesForServiceConcepts(final MicroserviceMapping mapping) {
    int _size = mapping.getTechnologies().size();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        final Import technologyImport = mapping.getTechnologies().get((i).intValue());
        final Technology technologyModel = DdmmUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        if (((technologyModel.getPrimitiveTypes().isEmpty() && 
          technologyModel.getProtocols().isEmpty()) && 
          technologyModel.getServiceAspects().isEmpty())) {
          this.error("Technology does not specify service-related concepts", 
            MappingPackage.Literals.MICROSERVICE_MAPPING__TECHNOLOGIES, (i).intValue());
        }
      }
    }
  }
  
  /**
   * Check technologies of a microservice mapping per communication type for unambiguous default
   * protocols
   */
  @Check
  public void checkTechnologiesForUniqueDefaultProtocols(final MicroserviceMapping mapping) {
    boolean _isEmpty = mapping.getTechnologies().isEmpty();
    if (_isEmpty) {
      return;
    }
    final Function1<CommunicationType, Boolean> _function = (CommunicationType communicationType) -> {
      final Function1<TechnologySpecificProtocolSpecification, Boolean> _function_1 = (TechnologySpecificProtocolSpecification it) -> {
        CommunicationType _communicationType = it.getCommunicationType();
        return Boolean.valueOf((communicationType == _communicationType));
      };
      boolean _exists = IterableExtensions.<TechnologySpecificProtocolSpecification>exists(mapping.getProtocols(), _function_1);
      return Boolean.valueOf((!_exists));
    };
    final Function1<CommunicationType, Boolean> _function_1 = (CommunicationType it) -> {
      boolean _isDefaultProtocolUnique = this.isDefaultProtocolUnique(mapping, it);
      return Boolean.valueOf((!_isDefaultProtocolUnique));
    };
    final Iterable<CommunicationType> nonUniqueCommunicationTypes = IterableExtensions.<CommunicationType>filter(IterableExtensions.<CommunicationType>filter(((Iterable<CommunicationType>)Conversions.doWrapArray(CommunicationType.values())), _function), _function_1);
    for (final CommunicationType communicationType : nonUniqueCommunicationTypes) {
      {
        String _switchResult = null;
        if (communicationType != null) {
          switch (communicationType) {
            case ASYNCHRONOUS:
              _switchResult = "asynchronous";
              break;
            case SYNCHRONOUS:
              _switchResult = "synchronous";
              break;
            default:
              break;
          }
        }
        final String typeString = _switchResult;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Ambiguous default protocol for ");
        _builder.append(typeString);
        _builder.append(" communication. The ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("mapping needs to explicitly specifiy a protocol for ");
        _builder_1.append(typeString);
        _builder_1.append(" ");
        String _plus = (_builder.toString() + _builder_1);
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("communication.");
        String _plus_1 = (_plus + _builder_2);
        this.error(_plus_1, mapping, 
          MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
      }
    }
  }
  
  /**
   * Helper to check if default protocol of a microservice mapping is unique for a given
   * communication type
   */
  private boolean isDefaultProtocolUnique(final MicroserviceMapping mapping, final CommunicationType communicationType) {
    boolean alreadyFoundDefaultProtocolForCommunicationType = false;
    EList<Import> _technologies = mapping.getTechnologies();
    for (final Import technologyImport : _technologies) {
      {
        final Technology technologyModel = DdmmUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        final Function1<Protocol, Boolean> _function = (Protocol it) -> {
          return Boolean.valueOf((it.isDefault() && (it.getCommunicationType() == communicationType)));
        };
        final boolean hasDefaultProtocolForCommunicationType = IterableExtensions.<Protocol>exists(technologyModel.getProtocols(), _function);
        if (hasDefaultProtocolForCommunicationType) {
          if (alreadyFoundDefaultProtocolForCommunicationType) {
            return false;
          } else {
            alreadyFoundDefaultProtocolForCommunicationType = true;
          }
        }
      }
    }
    return true;
  }
  
  /**
   * Check that service mappings are unique
   */
  @Check
  public void checkMappingUniqueness(final TechnologyMapping model) {
    final Function1<MicroserviceMapping, Boolean> _function = (MicroserviceMapping it) -> {
      boolean _isEmpty = it.getTechnologies().isEmpty();
      return Boolean.valueOf((!_isEmpty));
    };
    final List<MicroserviceMapping> modelMappingsWithTechnology = IterableExtensions.<MicroserviceMapping>toList(IterableExtensions.<MicroserviceMapping>filter(model.getMappings(), _function));
    final Function<MicroserviceMapping, String> _function_1 = (MicroserviceMapping it) -> {
      String _xblockexpression = null;
      {
        final ArrayList<String> qualifiedNameSegments = CollectionLiterals.<String>newArrayList();
        qualifiedNameSegments.addAll(it.getMicroservice().getMicroservice().getQualifiedNameParts());
        _xblockexpression = QualifiedName.create(qualifiedNameSegments).toString();
      }
      return _xblockexpression;
    };
    this.<MicroserviceMapping>checkMappingUniqueness(modelMappingsWithTechnology, "Service", _function_1, MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
  }
  
  /**
   * Check that interface mappings are unique
   */
  @Check
  public void checkInterfaceMappingUniqueness(final MicroserviceMapping microserviceMapping) {
    final Function<InterfaceMapping, String> _function = (InterfaceMapping it) -> {
      return QualifiedName.create(it.getInterface().getQualifiedNameParts()).toString();
    };
    this.<InterfaceMapping>checkMappingUniqueness(microserviceMapping.getInterfaceMappings(), "Interface", _function, 
      MappingPackage.Literals.INTERFACE_MAPPING__INTERFACE);
  }
  
  /**
   * Check that operation mappings are unique
   */
  @Check
  public void checkOperationMappingUniqueness(final MicroserviceMapping microserviceMapping) {
    final Function<OperationMapping, String> _function = (OperationMapping it) -> {
      return QualifiedName.create(it.getOperation().getQualifiedNameParts()).toString();
    };
    this.<OperationMapping>checkMappingUniqueness(microserviceMapping.getOperationMappings(), "Operation", _function, 
      MappingPackage.Literals.OPERATION_MAPPING__OPERATION);
  }
  
  /**
   * Check that referred operation mappings are unique
   */
  @Check
  public void checkReferredOperationMappingUniqueness(final MicroserviceMapping microserviceMapping) {
    final Function<ReferredOperationMapping, String> _function = (ReferredOperationMapping it) -> {
      return QualifiedName.create(it.getOperation().getQualifiedNameParts()).toString();
    };
    this.<ReferredOperationMapping>checkMappingUniqueness(microserviceMapping.getReferredOperationMappings(), "Referred operation", _function, 
      MappingPackage.Literals.REFERRED_OPERATION_MAPPING__OPERATION);
  }
  
  /**
   * Check that communication types and endpoint protocols of technology-specific protocol
   * specifications of a microservice mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final MicroserviceMapping microserviceMapping) {
    this.checkCommunicationTypeUniqueness(microserviceMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(microserviceMapping.getEndpoints());
  }
  
  /**
   * Check that communication types and endpoint protocols  of technology-specific protocol
   * specifications of an interface mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final InterfaceMapping interfaceMapping) {
    this.checkCommunicationTypeUniqueness(interfaceMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(interfaceMapping.getEndpoints());
  }
  
  /**
   * Check that communication types and endpoint protocols  of technology-specific protocol
   * specifications of an operation mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final OperationMapping operationMapping) {
    this.checkCommunicationTypeUniqueness(operationMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(operationMapping.getEndpoints());
  }
  
  /**
   * Check that communication types and endpoint protocols  of technology-specific protocol
   * specifications of a referred operation mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final ReferredOperationMapping operationMapping) {
    this.checkCommunicationTypeUniqueness(operationMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(operationMapping.getEndpoints());
  }
  
  /**
   * Helper to check that protocol/format combinations in endpoint mappings are unique
   */
  private void checkEndpointProtocolUniqueness(final List<TechnologySpecificEndpoint> endpoints) {
    final HashSet<String> protocolSet = CollectionLiterals.<String>newHashSet();
    final Consumer<TechnologySpecificEndpoint> _function = (TechnologySpecificEndpoint endpoint) -> {
      int _size = endpoint.getTechnologySpecificProtocols().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        {
          final TechnologySpecificProtocol technologySpecificProtocol = endpoint.getTechnologySpecificProtocols().get((i).intValue());
          String protocolId = technologySpecificProtocol.getProtocol().getName();
          if (((protocolId != null) && (technologySpecificProtocol.getDataFormat() != null))) {
            String _protocolId = protocolId;
            String _formatName = technologySpecificProtocol.getDataFormat().getFormatName();
            String _plus = ("/" + _formatName);
            protocolId = (_protocolId + _plus);
          }
          boolean _xifexpression = false;
          if ((protocolId != null)) {
            boolean _add = protocolSet.add(protocolId);
            _xifexpression = (!_add);
          } else {
            _xifexpression = false;
          }
          final boolean isDuplicate = _xifexpression;
          if (isDuplicate) {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Duplicate protocol specification for endpoint ");
            _builder.append(protocolId);
            this.error(_builder.toString(), endpoint, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__TECHNOLOGY_SPECIFIC_PROTOCOLS, (i).intValue());
          }
        }
      }
    };
    endpoints.forEach(_function);
  }
  
  /**
   * Check uniqueness of an endpoint's addresses
   */
  @Check
  public void checkUniqueEndpointAddresses(final TechnologySpecificEndpoint endpoint) {
    final Function<String, String> _function = (String it) -> {
      return it;
    };
    final Integer duplicateIndex = DdmmUtils.<String, String>getDuplicateIndex(endpoint.getAddresses(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final String duplicate = endpoint.getAddresses().get((duplicateIndex).intValue());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate address ");
      _builder.append(duplicate);
      this.error(_builder.toString(), endpoint, 
        MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that mapped microservice, interface, and operation technology-specific endpoints'
   * addresses are unique per protocol/data format combination
   */
  @Check
  public void checkUniqueEndpointAddresses(final TechnologyMapping model) {
    final Function1<MicroserviceMapping, EList<TechnologySpecificEndpoint>> _function = (MicroserviceMapping it) -> {
      return it.getEndpoints();
    };
    final List<TechnologySpecificEndpoint> microserviceEndpoints = IterableExtensions.<TechnologySpecificEndpoint>toList(Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<MicroserviceMapping, EList<TechnologySpecificEndpoint>>map(model.getMappings(), _function)));
    final Function<TechnologySpecificEndpoint, List<String>> _function_1 = (TechnologySpecificEndpoint it) -> {
      EList<String> _xblockexpression = null;
      {
        final ImportedMicroservice importedMicroservice = it.getMicroserviceMapping().getMicroservice();
        _xblockexpression = importedMicroservice.getMicroservice().getQualifiedNameParts();
      }
      return _xblockexpression;
    };
    this.checkUniqueEndpointAddresses(microserviceEndpoints, "microservice", _function_1);
    final Function1<InterfaceMapping, EList<TechnologySpecificEndpoint>> _function_2 = (InterfaceMapping it) -> {
      return it.getEndpoints();
    };
    final List<TechnologySpecificEndpoint> interfaceEndpoints = IterableExtensions.<TechnologySpecificEndpoint>toList(Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<InterfaceMapping, EList<TechnologySpecificEndpoint>>map(model.getMappedInterfaces(), _function_2)));
    final Function<TechnologySpecificEndpoint, List<String>> _function_3 = (TechnologySpecificEndpoint it) -> {
      return it.getInterfaceMapping().getInterface().getQualifiedNameParts();
    };
    this.checkUniqueEndpointAddresses(interfaceEndpoints, "interface", _function_3);
    final List<TechnologySpecificEndpoint> operationEndpoints = CollectionLiterals.<TechnologySpecificEndpoint>newArrayList();
    final Function1<ReferredOperationMapping, EList<TechnologySpecificEndpoint>> _function_4 = (ReferredOperationMapping it) -> {
      return it.getEndpoints();
    };
    Iterables.<TechnologySpecificEndpoint>addAll(operationEndpoints, Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<ReferredOperationMapping, EList<TechnologySpecificEndpoint>>map(model.getMappedReferredOperations(), _function_4)));
    final Function1<OperationMapping, EList<TechnologySpecificEndpoint>> _function_5 = (OperationMapping it) -> {
      return it.getEndpoints();
    };
    Iterables.<TechnologySpecificEndpoint>addAll(operationEndpoints, Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<OperationMapping, EList<TechnologySpecificEndpoint>>map(model.getMappedOperations(), _function_5)));
    final Function<TechnologySpecificEndpoint, List<String>> _function_6 = (TechnologySpecificEndpoint it) -> {
      EList<String> _xifexpression = null;
      OperationMapping _operationMapping = it.getOperationMapping();
      boolean _tripleNotEquals = (_operationMapping != null);
      if (_tripleNotEquals) {
        _xifexpression = it.getOperationMapping().getOperation().getQualifiedNameParts();
      } else {
        EList<String> _xifexpression_1 = null;
        ReferredOperationMapping _referredOperationMapping = it.getReferredOperationMapping();
        boolean _tripleNotEquals_1 = (_referredOperationMapping != null);
        if (_tripleNotEquals_1) {
          _xifexpression_1 = it.getReferredOperationMapping().getOperation().getQualifiedNameParts();
        }
        _xifexpression = _xifexpression_1;
      }
      return _xifexpression;
    };
    this.checkUniqueEndpointAddresses(operationEndpoints, "operation", _function_6);
  }
  
  /**
   * Check and warn if types of a primitive parameter mapping are not compatible. Note that we
   * just place a warning in case of (suspected) type incompatibility, as we also do it in the
   * service DSL.
   */
  @Check
  public void warnPrimitiveParameterMappingTypeCompatibility(final PrimitiveParameterMapping mapping) {
    this.warnParameterMappingTypeCompatibility(mapping);
  }
  
  /**
   * Check and warn if types of a complex parameter mapping are not compatible. Note that we just
   * place a warning in case of (suspected) type incompatibility, as we also do it in the service
   * DSL.
   */
  @Check
  public void warnComplexParameterMappingTypeCompatibility(final ComplexParameterMapping mapping) {
    this.warnParameterMappingTypeCompatibility(mapping);
  }
  
  /**
   * Check and warn if types of a data field mapping are not compatible. Note that we just place a
   * warning in case of (suspected) type incompatibility, as we also do it in the service DSL.
   */
  @Check
  public void warnComplexParameterMappingTypeCompatibility(final TechnologySpecificDataFieldTypeMapping mapping) {
    this.warnParameterMappingTypeCompatibility(mapping);
  }
  
  /**
   * Check that microservice mapping is not empty
   */
  @Check
  public void checkNotEmpty(final MicroserviceMapping mapping) {
    final boolean isEmpty = (((((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getInterfaceMappings().isEmpty()) && 
      mapping.getOperationMappings().isEmpty()) && 
      mapping.getReferredOperationMappings().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
    }
  }
  
  /**
   * Check that interface mapping is not empty
   */
  @Check
  public void checkNotEmpty(final InterfaceMapping mapping) {
    final boolean isEmpty = ((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.INTERFACE_MAPPING__INTERFACE);
    }
  }
  
  /**
   * Check that operation mapping is not empty
   */
  @Check
  public void checkNotEmpty(final OperationMapping mapping) {
    final boolean isEmpty = (((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getParameterMappings().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.OPERATION_MAPPING__OPERATION);
    }
  }
  
  /**
   * Check that referred operation mapping is not empty
   */
  @Check
  public void checkNotEmpty(final ReferredOperationMapping mapping) {
    final boolean isEmpty = ((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.REFERRED_OPERATION_MAPPING__OPERATION);
    }
  }
  
  /**
   * Check that a parameter is mapped only once in an operation mapping
   */
  @Check
  public void checkComplexParameterMappingUniqueParameters(final OperationMapping mapping) {
    final Function<ParameterMapping, Parameter> _function = (ParameterMapping it) -> {
      return it.getParameter();
    };
    final Integer duplicateIndex = DdmmUtils.<ParameterMapping, Parameter>getDuplicateIndex(mapping.getParameterMappings(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final ParameterMapping duplicateMapping = mapping.getParameterMappings().get((duplicateIndex).intValue());
      final Parameter duplicateParameter = mapping.getParameterMappings().get((duplicateIndex).intValue()).getParameter();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate mapping for parameter ");
      String _name = duplicateParameter.getName();
      _builder.append(_name);
      this.error(_builder.toString(), duplicateMapping, MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER);
    }
  }
  
  /**
   * Check that a data field is mapped only once in a complex parameter mapping
   */
  @Check
  public void checkComplexParameterMappingUniqueFields(final ComplexParameterMapping mapping) {
    final Function<TechnologySpecificDataFieldTypeMapping, DataField> _function = (TechnologySpecificDataFieldTypeMapping it) -> {
      return IterableExtensions.<DataField>last(it.getDataFieldHierarchy().getDataFields());
    };
    final Integer duplicateIndex = DdmmUtils.<TechnologySpecificDataFieldTypeMapping, DataField>getDuplicateIndex(mapping.getDataFieldMappings(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final TechnologySpecificDataFieldTypeMapping duplicateMapping = mapping.getDataFieldMappings().get((duplicateIndex).intValue());
      final DataField duplicateField = IterableExtensions.<DataField>last(duplicateMapping.getDataFieldHierarchy().getDataFields());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate mapping for data field ");
      String _name = duplicateField.getName();
      _builder.append(_name);
      this.error(_builder.toString(), duplicateMapping, 
        MappingPackage.Literals.TECHNOLOGY_SPECIFIC_DATA_FIELD_TYPE_MAPPING__DATA_FIELD_HIERARCHY);
    }
  }
  
  /**
   * Helper to check that communication types are unique
   */
  private void checkCommunicationTypeUniqueness(final List<TechnologySpecificProtocolSpecification> protocolSpecifications) {
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final int i : _doubleDotLessThan) {
      {
        CommunicationType _switchResult = null;
        switch (i) {
          case 0:
            _switchResult = CommunicationType.SYNCHRONOUS;
            break;
          case 1:
            _switchResult = CommunicationType.ASYNCHRONOUS;
            break;
        }
        final CommunicationType currentCommunicationType = _switchResult;
        String _switchResult_1 = null;
        if (currentCommunicationType != null) {
          switch (currentCommunicationType) {
            case SYNCHRONOUS:
              _switchResult_1 = "synchronous";
              break;
            case ASYNCHRONOUS:
              _switchResult_1 = "asynchronous";
              break;
            default:
              break;
          }
        }
        final String currentCommunicationTypeName = _switchResult_1;
        final Function<TechnologySpecificProtocolSpecification, CommunicationType> _function = (TechnologySpecificProtocolSpecification it) -> {
          return it.getCommunicationType();
        };
        final Predicate<TechnologySpecificProtocolSpecification> _function_1 = (TechnologySpecificProtocolSpecification it) -> {
          CommunicationType _communicationType = it.getCommunicationType();
          return Objects.equal(currentCommunicationType, _communicationType);
        };
        final Integer duplicateIndex = DdmmUtils.<TechnologySpecificProtocolSpecification, CommunicationType>getDuplicateIndex(protocolSpecifications, _function, _function_1);
        if (((duplicateIndex).intValue() == (-1))) {
          return;
        }
        final TechnologySpecificProtocolSpecification duplicate = protocolSpecifications.get((duplicateIndex).intValue());
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("There must not be more than one ");
        _builder.append(currentCommunicationTypeName);
        _builder.append(" protocol ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("being mapped");
        String _plus = (_builder.toString() + _builder_1);
        this.error(_plus, duplicate, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL_SPECIFICATION__COMMUNICATION_TYPE);
      }
    }
  }
  
  /**
   * Helper to check that service-specific mappings are unique
   */
  private <T extends EObject> void checkMappingUniqueness(final List<T> mappingsToCheck, final String mappingName, final Function<T, String> getMappingObjectName, final EReference mappingFeature) {
    final Integer duplicateIndex = DdmmUtils.<T, String>getDuplicateIndex(mappingsToCheck, getMappingObjectName);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final T duplicate = mappingsToCheck.get((duplicateIndex).intValue());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(mappingName);
    _builder.append(" is already mapped");
    this.error(_builder.toString(), duplicate, mappingFeature);
  }
  
  /**
   * Convenience method to check uniqueness of endpoint addresses within a list of endpoints
   */
  private void checkUniqueEndpointAddresses(final List<TechnologySpecificEndpoint> endpoints, final String containerTypeName, final Function<TechnologySpecificEndpoint, List<String>> getEndpointContainerNameParts) {
    final HashMap<String, Map<String, Object>> uniqueAddressMap = CollectionLiterals.<String, Map<String, Object>>newHashMap();
    final Consumer<TechnologySpecificEndpoint> _function = (TechnologySpecificEndpoint endpoint) -> {
      int _size = endpoint.getAddresses().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        final Consumer<TechnologySpecificProtocol> _function_1 = (TechnologySpecificProtocol technologySpecificProtocol) -> {
          final String address = endpoint.getAddresses().get((i).intValue());
          final Protocol protocol = technologySpecificProtocol.getProtocol();
          String protocolName = protocol.getName();
          final DataFormat dataFormat = technologySpecificProtocol.getDataFormat();
          if (((dataFormat != null) && (dataFormat.getFormatName() != null))) {
            String _protocolName = protocolName;
            String _formatName = dataFormat.getFormatName();
            String _plus = ("/" + _formatName);
            protocolName = (_protocolName + _plus);
          }
          final String addressPrefixedByProtocol = (protocolName + address);
          final HashMap<String, Object> valueMap = CollectionLiterals.<String, Object>newHashMap();
          valueMap.put("protocol", protocolName);
          valueMap.put("endpoint", endpoint);
          final Map<String, Object> duplicate = uniqueAddressMap.putIfAbsent(addressPrefixedByProtocol, valueMap);
          TechnologySpecificEndpoint _xifexpression = null;
          if ((duplicate != null)) {
            Object _get = duplicate.get("endpoint");
            _xifexpression = ((TechnologySpecificEndpoint) _get);
          }
          final TechnologySpecificEndpoint duplicateEndpoint = _xifexpression;
          if (((duplicateEndpoint != null) && (duplicateEndpoint != endpoint))) {
            Object _get_1 = duplicate.get("protocol");
            final String duplicateProtocolName = ((String) _get_1);
            final List<String> duplicateContainerNameParts = getEndpointContainerNameParts.apply(duplicateEndpoint);
            final List<String> currentEndpointContainerNameParts = getEndpointContainerNameParts.apply(endpoint);
            final String relativeDuplicateName = QualifiedName.create(
              DdmmUtils.<TechnologySpecificEndpoint, TechnologyMapping>calculateRelativeQualifiedNameParts(duplicateEndpoint, duplicateContainerNameParts, TechnologyMapping.class, endpoint, currentEndpointContainerNameParts, TechnologyMapping.class)).toString();
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Address is already specified for protocol ");
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append(duplicateProtocolName);
            _builder_1.append(" on ");
            String _plus_1 = (_builder.toString() + _builder_1);
            StringConcatenation _builder_2 = new StringConcatenation();
            _builder_2.append(containerTypeName);
            _builder_2.append(" ");
            _builder_2.append(relativeDuplicateName);
            String _plus_2 = (_plus_1 + _builder_2);
            this.error(_plus_2, endpoint, 
              MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES, (i).intValue());
          }
        };
        endpoint.getTechnologySpecificProtocols().forEach(_function_1);
      }
    };
    endpoints.forEach(_function);
  }
  
  /**
   * Convenience method for warning if types of a parameter mapping are not compatible with each
   * other
   */
  public void warnParameterMappingTypeCompatibility(final EObject mapping) {
    Type mappedType = null;
    String mappedTypeName = null;
    Type originalType = null;
    EStructuralFeature erroneousMappingFeature = null;
    boolean _matched = false;
    if (mapping instanceof PrimitiveParameterMapping) {
      _matched=true;
      mappedType = ((PrimitiveParameterMapping)mapping).getPrimitiveType();
      mappedTypeName = ((PrimitiveParameterMapping)mapping).getPrimitiveType().getName();
      originalType = ((PrimitiveParameterMapping)mapping).getParameter().getPrimitiveType();
      erroneousMappingFeature = MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER;
    }
    if (!_matched) {
      if (mapping instanceof ComplexParameterMapping) {
        _matched=true;
        mappedType = ((ComplexParameterMapping)mapping).getTechnologySpecificComplexType();
        mappedTypeName = ((ComplexParameterMapping)mapping).getTechnologySpecificComplexType().getName();
        originalType = ((ComplexParameterMapping)mapping).getParameter().getImportedType().getType();
        erroneousMappingFeature = MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER;
      }
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificDataFieldTypeMapping) {
        _matched=true;
        mappedType = ((TechnologySpecificDataFieldTypeMapping)mapping).getType();
        String _xifexpression = null;
        if ((mappedType instanceof TechnologySpecificPrimitiveType)) {
          _xifexpression = ((TechnologySpecificPrimitiveType)mappedType).getName();
        } else {
          String _xifexpression_1 = null;
          if ((mappedType instanceof ComplexType)) {
            _xifexpression_1 = ((ComplexType)mappedType).getName();
          }
          _xifexpression = _xifexpression_1;
        }
        mappedTypeName = _xifexpression;
        originalType = IterableExtensions.<DataField>last(((TechnologySpecificDataFieldTypeMapping)mapping).getDataFieldHierarchy().getDataFields()).getEffectiveType();
        erroneousMappingFeature = MappingPackage.Literals.TECHNOLOGY_SPECIFIC_DATA_FIELD_TYPE_MAPPING__DATA_FIELD_HIERARCHY;
      }
    }
    if (((originalType == null) || (mappedType == null))) {
      return;
    }
    try {
      new TypeChecker().checkTypeCompatibility(originalType, mappedType);
    } catch (final Throwable _t) {
      if (_t instanceof TypesNotCompatibleException) {
        final TypesNotCompatibleException ex = (TypesNotCompatibleException)_t;
        final String originalTypeName = this.buildMappedTypeQualifiedName(mapping, originalType);
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Original type ");
        _builder.append(originalTypeName);
        _builder.append(" of parameter is not directly ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("compatible with mapped type ");
        _builder_1.append(mappedTypeName);
        _builder_1.append(" ");
        String _plus = (_builder.toString() + _builder_1);
        this.warning(_plus, mapping, erroneousMappingFeature);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  /**
   * Check uniqueness of aspects
   */
  @Check
  public void checkAspectsUniqueness(final TechnologySpecificImportedServiceAspect importedAspect) {
    if (((((importedAspect.getTechnology() == null) || (importedAspect.getTechnology().getName() == null)) || 
      (importedAspect.getAspect() == null)) || (importedAspect.getAspect().getName() == null))) {
      return;
    }
    final List<TechnologySpecificImportedServiceAspect> allAspectsOfContainer = EcoreUtil2.<TechnologySpecificImportedServiceAspect>getSiblingsOfType(importedAspect.eContainer(), 
      TechnologySpecificImportedServiceAspect.class);
    final Function<TechnologySpecificImportedServiceAspect, String> _function = (TechnologySpecificImportedServiceAspect it) -> {
      return QualifiedName.create(importedAspect.getTechnology().getName(), it.getAspect().getName()).toString();
    };
    final Predicate<TechnologySpecificImportedServiceAspect> _function_1 = (TechnologySpecificImportedServiceAspect it) -> {
      String _name = it.getAspect().getName();
      return (_name != null);
    };
    final Integer duplicateIndex = DdmmUtils.<TechnologySpecificImportedServiceAspect, String>getDuplicateIndex(allAspectsOfContainer, _function, _function_1);
    if (((duplicateIndex).intValue() > (-1))) {
      final TechnologySpecificImportedServiceAspect duplicateAspect = allAspectsOfContainer.get((duplicateIndex).intValue());
      this.error("Aspect was already specified", duplicateAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT);
    }
  }
  
  /**
   * Check that aspect has only one property, if only a single value is specified, and that the
   * specified value matches the property's type
   */
  @Check
  public void checkSingleAspectProperty(final TechnologySpecificImportedServiceAspect importedAspect) {
    final PrimitiveValue propertyValue = importedAspect.getSinglePropertyValue();
    if ((propertyValue == null)) {
      return;
    }
    final int propertyCount = importedAspect.getAspect().getProperties().size();
    if ((propertyCount > 1)) {
      this.error("Ambiguous value assignment", importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
    } else {
      if ((propertyCount == 1)) {
        final TechnologySpecificProperty targetProperty = importedAspect.getAspect().getProperties().get(0);
        final PrimitiveType targetPropertyType = targetProperty.getType();
        boolean _isOfType = propertyValue.isOfType(targetPropertyType);
        boolean _not = (!_isOfType);
        if (_not) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Value is not of type ");
          String _typeName = targetPropertyType.getTypeName();
          _builder.append(_typeName);
          _builder.append(" as expected by ");
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("property ");
          String _name = targetProperty.getName();
          _builder_1.append(_name);
          String _plus = (_builder.toString() + _builder_1);
          this.error(_plus, importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
        }
      }
    }
  }
  
  /**
   * Check that mandatory properties of aspects have values
   */
  @Check
  public void checkMandatoryAspectProperties(final TechnologySpecificImportedServiceAspect importedAspect) {
    final ServiceAspect aspect = importedAspect.getAspect();
    final EList<TechnologySpecificProperty> aspectProperties = aspect.getProperties();
    final Function1<TechnologySpecificProperty, Boolean> _function = (TechnologySpecificProperty it) -> {
      return Boolean.valueOf(it.isMandatory());
    };
    final Iterable<TechnologySpecificProperty> mandatoryProperties = IterableExtensions.<TechnologySpecificProperty>filter(aspectProperties, _function);
    final Function1<TechnologySpecificProperty, Boolean> _function_1 = (TechnologySpecificProperty it) -> {
      final Function1<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty> _function_2 = (TechnologySpecificPropertyValueAssignment it_1) -> {
        return it_1.getProperty();
      };
      boolean _contains = ListExtensions.<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty>map(importedAspect.getValues(), _function_2).contains(it);
      return Boolean.valueOf((!_contains));
    };
    final Iterable<TechnologySpecificProperty> mandatoryPropertiesWithoutValues = IterableExtensions.<TechnologySpecificProperty>filter(mandatoryProperties, _function_1);
    final boolean allMandatoryPropertiesHaveValues = IterableExtensions.isEmpty(mandatoryPropertiesWithoutValues);
    final boolean aspectHasExactlyOneMandatoryProperty = ((aspectProperties.size() == 1) && 
      (!IterableExtensions.isEmpty(mandatoryProperties)));
    if (aspectHasExactlyOneMandatoryProperty) {
      if (((importedAspect.getSinglePropertyValue() == null) && (!allMandatoryPropertiesHaveValues))) {
        final TechnologySpecificProperty mandatoryProperty = ((TechnologySpecificProperty[])Conversions.unwrapArray(mandatoryProperties, TechnologySpecificProperty.class))[0];
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Mandatory property ");
        String _name = mandatoryProperty.getName();
        _builder.append(_name);
        _builder.append(" does not have value");
        this.error(_builder.toString(), importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT);
      }
    } else {
      if ((!allMandatoryPropertiesHaveValues)) {
        final Consumer<TechnologySpecificProperty> _function_2 = (TechnologySpecificProperty it) -> {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Mandatory property ");
          String _name_1 = it.getName();
          _builder_1.append(_name_1);
          _builder_1.append(" does not have value");
          this.error(_builder_1.toString(), importedAspect, 
            MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT);
        };
        mandatoryPropertiesWithoutValues.forEach(_function_2);
      }
    }
  }
  
  /**
   * Convenience method to build a qualified name for a type being used in a parameter mapping
   */
  private String buildMappedTypeQualifiedName(final EObject mapping, final Type type) {
    String importAlias = null;
    List<String> nameParts = null;
    boolean _matched = false;
    if (mapping instanceof PrimitiveParameterMapping) {
      _matched=true;
      boolean _matched_1 = false;
      if (type instanceof TechnologySpecificPrimitiveType) {
        _matched_1=true;
        importAlias = ((PrimitiveParameterMapping)mapping).getParameter().getImportedType().getImport().getName();
        nameParts = ((TechnologySpecificPrimitiveType)type).getQualifiedNameParts();
      }
      if (!_matched_1) {
        if (type instanceof PrimitiveType) {
          _matched_1=true;
          String _typeName = ((PrimitiveType)type).getTypeName();
          nameParts = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(_typeName));
        }
      }
    }
    if (!_matched) {
      if (mapping instanceof ComplexParameterMapping) {
        _matched=true;
        boolean _matched_1 = false;
        if (type instanceof ComplexType) {
          _matched_1=true;
          importAlias = ((ComplexParameterMapping)mapping).getParameter().getImportedType().getImport().getName();
          nameParts = ((ComplexType)type).getQualifiedNameParts();
        }
      }
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificDataFieldTypeMapping) {
        _matched=true;
        boolean _matched_1 = false;
        if (type instanceof PrimitiveType) {
          _matched_1=true;
          String _typeName = ((PrimitiveType)type).getTypeName();
          nameParts = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(_typeName));
        }
        if (!_matched_1) {
          if (type instanceof ComplexType) {
            _matched_1=true;
            importAlias = ((TechnologySpecificDataFieldTypeMapping)mapping).getParameterMapping().getParameter().getImportedType().getImport().getName();
            nameParts = ((ComplexType)type).getQualifiedNameParts();
          }
        }
      }
    }
    String qualifiedName = QualifiedName.create(nameParts).toString();
    if ((importAlias != null)) {
      qualifiedName = ((importAlias + "::") + qualifiedName);
    }
    return qualifiedName;
  }
}
