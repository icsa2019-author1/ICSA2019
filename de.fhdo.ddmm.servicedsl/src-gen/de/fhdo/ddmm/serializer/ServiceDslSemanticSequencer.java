/*
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.serializer;

import com.google.inject.Inject;
import de.fhdo.ddmm.data.ComplexTypeImport;
import de.fhdo.ddmm.data.Context;
import de.fhdo.ddmm.data.DataField;
import de.fhdo.ddmm.data.DataModel;
import de.fhdo.ddmm.data.DataPackage;
import de.fhdo.ddmm.data.DataStructure;
import de.fhdo.ddmm.data.ListType;
import de.fhdo.ddmm.data.PossiblyImportedComplexType;
import de.fhdo.ddmm.data.PrimitiveBoolean;
import de.fhdo.ddmm.data.PrimitiveByte;
import de.fhdo.ddmm.data.PrimitiveCharacter;
import de.fhdo.ddmm.data.PrimitiveDate;
import de.fhdo.ddmm.data.PrimitiveDouble;
import de.fhdo.ddmm.data.PrimitiveFloat;
import de.fhdo.ddmm.data.PrimitiveInteger;
import de.fhdo.ddmm.data.PrimitiveLong;
import de.fhdo.ddmm.data.PrimitiveShort;
import de.fhdo.ddmm.data.PrimitiveString;
import de.fhdo.ddmm.data.PrimitiveValue;
import de.fhdo.ddmm.data.Version;
import de.fhdo.ddmm.service.Endpoint;
import de.fhdo.ddmm.service.Import;
import de.fhdo.ddmm.service.ImportedProtocolAndDataFormat;
import de.fhdo.ddmm.service.ImportedServiceAspect;
import de.fhdo.ddmm.service.ImportedType;
import de.fhdo.ddmm.service.Interface;
import de.fhdo.ddmm.service.Microservice;
import de.fhdo.ddmm.service.Operation;
import de.fhdo.ddmm.service.PossiblyImportedInterface;
import de.fhdo.ddmm.service.PossiblyImportedMicroservice;
import de.fhdo.ddmm.service.PossiblyImportedOperation;
import de.fhdo.ddmm.service.ProtocolSpecification;
import de.fhdo.ddmm.service.ReferredOperation;
import de.fhdo.ddmm.service.ServiceModel;
import de.fhdo.ddmm.service.ServicePackage;
import de.fhdo.ddmm.services.ServiceDslGrammarAccess;
import de.fhdo.ddmm.technology.CompatibilityMatrixEntry;
import de.fhdo.ddmm.technology.DataFormat;
import de.fhdo.ddmm.technology.DeploymentTechnology;
import de.fhdo.ddmm.technology.InfrastructureTechnology;
import de.fhdo.ddmm.technology.OperationAspect;
import de.fhdo.ddmm.technology.OperationEnvironment;
import de.fhdo.ddmm.technology.PossiblyImportedTechnologySpecificType;
import de.fhdo.ddmm.technology.Protocol;
import de.fhdo.ddmm.technology.ServiceAspect;
import de.fhdo.ddmm.technology.ServiceAspectPointcut;
import de.fhdo.ddmm.technology.ServiceAspectPointcutSelector;
import de.fhdo.ddmm.technology.Technology;
import de.fhdo.ddmm.technology.TechnologyImport;
import de.fhdo.ddmm.technology.TechnologyPackage;
import de.fhdo.ddmm.technology.TechnologySpecificDataStructure;
import de.fhdo.ddmm.technology.TechnologySpecificListType;
import de.fhdo.ddmm.technology.TechnologySpecificPrimitiveType;
import de.fhdo.ddmm.technology.TechnologySpecificProperty;
import de.fhdo.ddmm.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.ddmm.technology.serializer.TechnologyDslSemanticSequencer;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ServiceDslSemanticSequencer extends TechnologyDslSemanticSequencer {

	@Inject
	private ServiceDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DataPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DataPackage.COMPLEX_TYPE_IMPORT:
				sequence_ComplexTypeImport(context, (ComplexTypeImport) semanticObject); 
				return; 
			case DataPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			case DataPackage.DATA_FIELD:
				sequence_DataField(context, (DataField) semanticObject); 
				return; 
			case DataPackage.DATA_MODEL:
				sequence_DataModel(context, (DataModel) semanticObject); 
				return; 
			case DataPackage.DATA_STRUCTURE:
				sequence_DataStructure(context, (DataStructure) semanticObject); 
				return; 
			case DataPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case DataPackage.POSSIBLY_IMPORTED_COMPLEX_TYPE:
				sequence_PossiblyImportedComplexType(context, (PossiblyImportedComplexType) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_BOOLEAN:
				sequence_PrimitiveType(context, (PrimitiveBoolean) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_BYTE:
				sequence_PrimitiveType(context, (PrimitiveByte) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_CHARACTER:
				sequence_PrimitiveType(context, (PrimitiveCharacter) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_DATE:
				sequence_PrimitiveType(context, (PrimitiveDate) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_DOUBLE:
				sequence_PrimitiveType(context, (PrimitiveDouble) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_FLOAT:
				sequence_PrimitiveType(context, (PrimitiveFloat) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_INTEGER:
				sequence_PrimitiveType(context, (PrimitiveInteger) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_LONG:
				sequence_PrimitiveType(context, (PrimitiveLong) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_SHORT:
				sequence_PrimitiveType(context, (PrimitiveShort) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_STRING:
				sequence_PrimitiveType(context, (PrimitiveString) semanticObject); 
				return; 
			case DataPackage.PRIMITIVE_VALUE:
				sequence_PrimitiveValue(context, (PrimitiveValue) semanticObject); 
				return; 
			case DataPackage.VERSION:
				sequence_Version(context, (Version) semanticObject); 
				return; 
			}
		else if (epackage == ServicePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ServicePackage.ENDPOINT:
				sequence_Endpoint(context, (Endpoint) semanticObject); 
				return; 
			case ServicePackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ServicePackage.IMPORTED_PROTOCOL_AND_DATA_FORMAT:
				sequence_ImportedProtocolAndDataFormat(context, (ImportedProtocolAndDataFormat) semanticObject); 
				return; 
			case ServicePackage.IMPORTED_SERVICE_ASPECT:
				sequence_ImportedServiceAspect(context, (ImportedServiceAspect) semanticObject); 
				return; 
			case ServicePackage.IMPORTED_TYPE:
				sequence_ImportedType(context, (ImportedType) semanticObject); 
				return; 
			case ServicePackage.INTERFACE:
				sequence_Interface(context, (Interface) semanticObject); 
				return; 
			case ServicePackage.MICROSERVICE:
				sequence_Microservice(context, (Microservice) semanticObject); 
				return; 
			case ServicePackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case ServicePackage.PARAMETER:
				sequence_Parameter(context, (de.fhdo.ddmm.service.Parameter) semanticObject); 
				return; 
			case ServicePackage.POSSIBLY_IMPORTED_INTERFACE:
				sequence_PossiblyImportedInterface(context, (PossiblyImportedInterface) semanticObject); 
				return; 
			case ServicePackage.POSSIBLY_IMPORTED_MICROSERVICE:
				sequence_PossiblyImportedMicroservice(context, (PossiblyImportedMicroservice) semanticObject); 
				return; 
			case ServicePackage.POSSIBLY_IMPORTED_OPERATION:
				sequence_PossiblyImportedOperation(context, (PossiblyImportedOperation) semanticObject); 
				return; 
			case ServicePackage.PROTOCOL_SPECIFICATION:
				sequence_ProtocolSpecification(context, (ProtocolSpecification) semanticObject); 
				return; 
			case ServicePackage.REFERRED_OPERATION:
				sequence_ReferredOperation(context, (ReferredOperation) semanticObject); 
				return; 
			case ServicePackage.SERVICE_MODEL:
				sequence_ServiceModel(context, (ServiceModel) semanticObject); 
				return; 
			}
		else if (epackage == TechnologyPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TechnologyPackage.COMPATIBILITY_MATRIX_ENTRY:
				sequence_CompatibilityMatrixEntry(context, (CompatibilityMatrixEntry) semanticObject); 
				return; 
			case TechnologyPackage.DATA_FORMAT:
				sequence_DataFormat(context, (DataFormat) semanticObject); 
				return; 
			case TechnologyPackage.DEPLOYMENT_TECHNOLOGY:
				sequence_DeploymentTechnology(context, (DeploymentTechnology) semanticObject); 
				return; 
			case TechnologyPackage.INFRASTRUCTURE_TECHNOLOGY:
				sequence_InfrastructureTechnology(context, (InfrastructureTechnology) semanticObject); 
				return; 
			case TechnologyPackage.OPERATION_ASPECT:
				sequence_OperationAspect(context, (OperationAspect) semanticObject); 
				return; 
			case TechnologyPackage.OPERATION_ENVIRONMENT:
				sequence_OperationEnvironment(context, (OperationEnvironment) semanticObject); 
				return; 
			case TechnologyPackage.POSSIBLY_IMPORTED_TECHNOLOGY_SPECIFIC_TYPE:
				sequence_PossiblyImportedTechnologySpecificType(context, (PossiblyImportedTechnologySpecificType) semanticObject); 
				return; 
			case TechnologyPackage.PROTOCOL:
				sequence_Protocol(context, (Protocol) semanticObject); 
				return; 
			case TechnologyPackage.SERVICE_ASPECT:
				sequence_ServiceAspect(context, (ServiceAspect) semanticObject); 
				return; 
			case TechnologyPackage.SERVICE_ASPECT_POINTCUT:
				sequence_ServiceAspectPointcut(context, (ServiceAspectPointcut) semanticObject); 
				return; 
			case TechnologyPackage.SERVICE_ASPECT_POINTCUT_SELECTOR:
				sequence_ServiceAspectPointcutSelector(context, (ServiceAspectPointcutSelector) semanticObject); 
				return; 
			case TechnologyPackage.TECHNOLOGY:
				sequence_Technology(context, (Technology) semanticObject); 
				return; 
			case TechnologyPackage.TECHNOLOGY_IMPORT:
				sequence_TechnologyImport(context, (TechnologyImport) semanticObject); 
				return; 
			case TechnologyPackage.TECHNOLOGY_SPECIFIC_DATA_STRUCTURE:
				sequence_TechnologySpecificDataStructure(context, (TechnologySpecificDataStructure) semanticObject); 
				return; 
			case TechnologyPackage.TECHNOLOGY_SPECIFIC_LIST_TYPE:
				sequence_TechnologySpecificListType(context, (TechnologySpecificListType) semanticObject); 
				return; 
			case TechnologyPackage.TECHNOLOGY_SPECIFIC_PRIMITIVE_TYPE:
				sequence_TechnologySpecificPrimitiveType(context, (TechnologySpecificPrimitiveType) semanticObject); 
				return; 
			case TechnologyPackage.TECHNOLOGY_SPECIFIC_PROPERTY:
				sequence_TechnologySpecificProperty(context, (TechnologySpecificProperty) semanticObject); 
				return; 
			case TechnologyPackage.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT:
				sequence_PropertyValueAssignment(context, (TechnologySpecificPropertyValueAssignment) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Endpoint returns Endpoint
	 *
	 * Constraint:
	 *     (protocols+=ImportedProtocolAndDataFormat protocols+=ImportedProtocolAndDataFormat* addresses+=STRING addresses+=STRING*)
	 */
	protected void sequence_Endpoint(ISerializationContext context, Endpoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (importType=ImportType importURI=STRING name=ID)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ServicePackage.Literals.IMPORT__IMPORT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ServicePackage.Literals.IMPORT__IMPORT_TYPE));
			if (transientValues.isValueTransient(semanticObject, ServicePackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ServicePackage.Literals.IMPORT__IMPORT_URI));
			if (transientValues.isValueTransient(semanticObject, ServicePackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ServicePackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportTypeImportTypeEnumRuleCall_1_0(), semanticObject.getImportType());
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_3_0(), semanticObject.getImportURI());
		feeder.accept(grammarAccess.getImportAccess().getNameIDTerminalRuleCall_5_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImportedProtocolAndDataFormat returns ImportedProtocolAndDataFormat
	 *
	 * Constraint:
	 *     (import=[Import|ID] importedProtocol=[Protocol|QualifiedName] dataFormat=[DataFormat|ID]?)
	 */
	protected void sequence_ImportedProtocolAndDataFormat(ISerializationContext context, ImportedProtocolAndDataFormat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportedServiceAspect returns ImportedServiceAspect
	 *
	 * Constraint:
	 *     (
	 *         import=[Import|ID] 
	 *         importedAspect=[ServiceAspect|QualifiedName] 
	 *         (singlePropertyValue=PrimitiveValue | (values+=PropertyValueAssignment values+=PropertyValueAssignment*))?
	 *     )
	 */
	protected void sequence_ImportedServiceAspect(ISerializationContext context, ImportedServiceAspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportedType returns ImportedType
	 *
	 * Constraint:
	 *     (import=[Import|ID] type=[Type|QualifiedName])
	 */
	protected void sequence_ImportedType(ISerializationContext context, ImportedType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ServicePackage.Literals.IMPORTED_TYPE__IMPORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ServicePackage.Literals.IMPORTED_TYPE__IMPORT));
			if (transientValues.isValueTransient(semanticObject, ServicePackage.Literals.IMPORTED_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ServicePackage.Literals.IMPORTED_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportedTypeAccess().getImportImportIDTerminalRuleCall_0_0_1(), semanticObject.eGet(ServicePackage.Literals.IMPORTED_TYPE__IMPORT, false));
		feeder.accept(grammarAccess.getImportedTypeAccess().getTypeTypeQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(ServicePackage.Literals.IMPORTED_TYPE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Interface returns Interface
	 *
	 * Constraint:
	 *     (
	 *         (protocols+=ProtocolSpecification protocols+=ProtocolSpecification?)? 
	 *         endpoints+=Endpoint* 
	 *         aspects+=ImportedServiceAspect* 
	 *         notImplemented?='noimpl'? 
	 *         visibility=Visibility? 
	 *         name=ID 
	 *         referredOperations+=ReferredOperation* 
	 *         operations+=Operation*
	 *     )
	 */
	protected void sequence_Interface(ISerializationContext context, Interface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Microservice returns Microservice
	 *
	 * Constraint:
	 *     (
	 *         technologies+=[Import|ID]* 
	 *         (protocols+=ProtocolSpecification protocols+=ProtocolSpecification?)? 
	 *         endpoints+=Endpoint* 
	 *         aspects+=ImportedServiceAspect* 
	 *         visibility=Visibility? 
	 *         type=MicroserviceType 
	 *         name=QualifiedNameWithAtLeastOneLevel 
	 *         version=ID? 
	 *         (requiredMicroservices+=PossiblyImportedMicroservice requiredMicroservices+=PossiblyImportedMicroservice*)? 
	 *         (requiredInterfaces+=PossiblyImportedInterface requiredInterfaces+=PossiblyImportedInterface*)? 
	 *         (requiredOperations+=PossiblyImportedOperation requiredOperations+=PossiblyImportedOperation*)? 
	 *         interfaces+=Interface+
	 *     )
	 */
	protected void sequence_Microservice(ISerializationContext context, Microservice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (
	 *         (protocols+=ProtocolSpecification protocols+=ProtocolSpecification?)? 
	 *         endpoints+=Endpoint* 
	 *         aspects+=ImportedServiceAspect* 
	 *         notImplemented?='noimpl'? 
	 *         visibility=Visibility? 
	 *         name=ID 
	 *         parameters+=Parameter? 
	 *         parameters+=Parameter*
	 *     )
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         aspects+=ImportedServiceAspect* 
	 *         communicationType=CommunicationType 
	 *         exchangePattern=ExchangePattern? 
	 *         communicatesFault?='fault'? 
	 *         name=ID 
	 *         optional?='?'? 
	 *         (primitiveType=PrimitiveType | importedType=ImportedType) 
	 *         initializedByOperation=PossiblyImportedOperation?
	 *     )
	 */
	protected void sequence_Parameter(ISerializationContext context, de.fhdo.ddmm.service.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PossiblyImportedInterface returns PossiblyImportedInterface
	 *
	 * Constraint:
	 *     (import=[Import|ID]? interface=[Interface|QualifiedName])
	 */
	protected void sequence_PossiblyImportedInterface(ISerializationContext context, PossiblyImportedInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PossiblyImportedMicroservice returns PossiblyImportedMicroservice
	 *
	 * Constraint:
	 *     (import=[Import|ID]? microservice=[Microservice|QualifiedName])
	 */
	protected void sequence_PossiblyImportedMicroservice(ISerializationContext context, PossiblyImportedMicroservice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PossiblyImportedOperation returns PossiblyImportedOperation
	 *
	 * Constraint:
	 *     (import=[Import|ID]? operation=[Operation|QualifiedName])
	 */
	protected void sequence_PossiblyImportedOperation(ISerializationContext context, PossiblyImportedOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimitiveValue returns PrimitiveValue
	 *
	 * Constraint:
	 *     (numericValue=BIG_DECIMAL | booleanValue=BOOLEAN | stringValue=STRING)
	 */
	protected void sequence_PrimitiveValue(ISerializationContext context, PrimitiveValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyValueAssignment returns TechnologySpecificPropertyValueAssignment
	 *
	 * Constraint:
	 *     (property=[TechnologySpecificProperty|ID] value=PrimitiveValue)
	 */
	protected void sequence_PropertyValueAssignment(ISerializationContext context, TechnologySpecificPropertyValueAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY));
			if (transientValues.isValueTransient(semanticObject, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyValueAssignmentAccess().getPropertyTechnologySpecificPropertyIDTerminalRuleCall_0_0_1(), semanticObject.eGet(TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY, false));
		feeder.accept(grammarAccess.getPropertyValueAssignmentAccess().getValuePrimitiveValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProtocolSpecification returns ProtocolSpecification
	 *
	 * Constraint:
	 *     (communicationType=CommunicationType protocol=ImportedProtocolAndDataFormat)
	 */
	protected void sequence_ProtocolSpecification(ISerializationContext context, ProtocolSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ServicePackage.Literals.PROTOCOL_SPECIFICATION__COMMUNICATION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ServicePackage.Literals.PROTOCOL_SPECIFICATION__COMMUNICATION_TYPE));
			if (transientValues.isValueTransient(semanticObject, ServicePackage.Literals.PROTOCOL_SPECIFICATION__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ServicePackage.Literals.PROTOCOL_SPECIFICATION__PROTOCOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProtocolSpecificationAccess().getCommunicationTypeCommunicationTypeEnumRuleCall_1_0(), semanticObject.getCommunicationType());
		feeder.accept(grammarAccess.getProtocolSpecificationAccess().getProtocolImportedProtocolAndDataFormatParserRuleCall_3_0(), semanticObject.getProtocol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReferredOperation returns ReferredOperation
	 *
	 * Constraint:
	 *     (
	 *         (protocols+=ProtocolSpecification protocols+=ProtocolSpecification?)? 
	 *         endpoints+=Endpoint* 
	 *         aspects+=ImportedServiceAspect* 
	 *         operation=[Operation|QualifiedName]
	 *     )
	 */
	protected void sequence_ReferredOperation(ISerializationContext context, ReferredOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ServiceModel returns ServiceModel
	 *
	 * Constraint:
	 *     (imports+=Import* microservices+=Microservice+)
	 */
	protected void sequence_ServiceModel(ISerializationContext context, ServiceModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
